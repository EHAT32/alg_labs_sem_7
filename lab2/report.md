# ЛР 2. Структуры данных и динамическое программирование

## Задача

Поиск оптимального (кратчайшего, быстрейшего или самого дешевого) пути, проходящего через промежуточный пункты по одному разу и возвращающегося в исходную точку. К примеру, нахождение наиболее выгодного маршрута, позволяющего коммивояжеру посетить со своим товаром определенные города по одному разу и вернуться обратно. Мерой выгодности маршрута может быть минимальная длина пути.

## Решение

План решения задачи:

1. Задаётся вектор, состоящий из координат (X, Y) городов, которые необходимо посетить. Функция ```createGraph``` создаёт граф в виде матрицы, которая содержит информацию о расстоянии между каждым городом.

2. Создание таблицы мемоизации: Создаётся 2D таблица мемоизации размера(2^n) x n, где n - число городов. Первая ось задаёт множество посещённых городов, а второе - текущий город.

3. Инициализация таблицы: Таблица инициализируется простыми случаями, когда стартовый город посещён, а другие нет. В этих случаях расстояние равно 0.

4. Заполнение таблицы мемоизации: Для каждого подмножества посещённых городов и для каждого конечного пункта подсчитывается минимальное расстояние для прохождения всех городов в подмножестве по маршруту, который заканчивается в конечном пункте. Это достигается рассмотрением всех городов, которые были посещены до конечного пункта. В таблице хранятся минимальные расстояния.

5. Найти кратчайший путь: После заполнения таблицы ищем кратчайший путь, начиная в стартовом пункте, Перебираем все города и находим из таблицы минимальное расстояние.

## Сложность алгоритма

Прохождение по всем возможным множествам посещённых городов это $O(2^n)$, перебор всех пар городов в текущем множестве: $O(n^2)$, итого $T(n) = O(2^n \cdot n^2)$

Асимптотика по памяти: нужно лишь учитывать размер таблицы мемоизации: $M(n) = O(2^n \cdot n)$